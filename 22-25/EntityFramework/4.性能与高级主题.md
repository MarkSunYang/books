## EF 查询性能？

1. 使用 AsNoTracking()：对于只读查询，使用 AsNoTracking() 可以禁用更改跟踪，显著提升性能，因为 EF 不会为这些实体创建跟踪快照。
2. 谨慎使用延迟加载：避免 N+1 查询问题。
3. 使用投影（Select）：只查询你需要的字段，而不是整个实体。context.Users.Select(u => new { u.Id, u.Name }).ToList()
4. 合理使用 Include：不要过度使用 Include 加载大量不需要的关联数据。
5. 理解 SQL：使用 context.Database.Log（EF6）或配置日志（EF Core）来查看 EF 生成的 SQL，分析其效率。

## 原始 SQL 查询？什么时候使用
方法：FromSqlRaw / FromSqlInterpolated 用于查询，ExecuteSqlRaw / ExecuteSqlInterpolated 用于非查询命令。
使用场景：
当 LINQ 无法生成高效的 SQL 时（例如，复杂的报表查询）。
需要调用存储过程或使用特定的数据库函数时。
性能要求极高，需要手动优化 SQL。


## IQueryable<T> 和 IEnumerable<T>的区别
IQueryable<T> 的查询逻辑在数据库端执行
IEnumerable<T> 的查询逻辑在应用程序内存中执行

方面	   IQueryable<T>	IEnumerable<T>
命名空间	System.Linq	S   ystem.Collections
执行位置	数据库服务器	    应用程序内存
查询构成	表达式树	        委托
延迟执行	支持	            支持
适用场景	远程数据源（数据库、Web API）	本地内存集合
性能影响	只传输过滤后的结果	可能传输全部数据到内存再过滤

1. IQueryable<T>（在数据库端过滤）
当你对 IQueryable<T> 进行查询操作时（如 Where, OrderBy, Select），这些操作不会立即执行。
它们被构造成一个表达式树，这个树代表了你的整个查询逻辑。
当你物化查询时（调用 ToList(), First(), Count() 等），EF 或 LINQ Provider 会将这个表达式树翻译成特定数据库的 SQL 语句。
只有最终的查询结果会被从数据库传输到应用程序。
```
// 假设数据库中有 100 万条用户记录
var query = context.Users                 // IQueryable<User>
                   .Where(u => u.Age > 18)
                   .OrderBy(u => u.Name)
                   .Select(u => new { u.Name, u.Email });

// 此时还没有执行任何数据库查询
// 只是构建了一个表达式树

var result = query.Take(10).ToList();     // 现在执行查询

// 生成的 SQL 类似于：
// SELECT TOP 10 [u].[Name], [u].[Email] 
// FROM [Users] AS [u]
// WHERE [u].[Age] > 18
// ORDER BY [u].[Name]
```

2. IEnumerable<T>（在内存中过滤）
工作原理：

当你对 IEnumerable<T> 进行查询操作时，这些操作是针对已经在内存中的数据集合。
查询使用委托来表示，操作会立即在内存中执行（当迭代时）。
如果数据源来自数据库，所有数据必须先被加载到内存中，然后才能在内存中过滤。

```
// 危险！先将所有用户加载到内存
var allUsers = context.Users.ToList();    // IEnumerable<User> - 执行查询，加载 100 万条记录

// 现在在内存中对这 100 万条记录进行过滤
var filteredUsers = allUsers              // IEnumerable<User>
                      .Where(u => u.Age > 18)
                      .OrderBy(u => u.Name)
                      .Select(u => new { u.Name, u.Email })
                      .Take(10)
                      .ToList();

// 没有生成额外的 SQL
// 所有过滤、排序都在应用程序内存中完成
```

使用 IQueryable<T> 的场景：
数据库查询：几乎所有 EF/LINQ to SQL 查询都应该保持为 IQueryable<T> 直到需要结果。
需要数据库端操作：当你想利用数据库的索引、聚合函数等特性时。
分页查询：结合 Skip() 和 Take() 在数据库端实现高效分页。
动态查询构建：根据条件动态添加 Where 子句。


使用 IEnumerable<T> 的场景：
处理内存中的数据：对 List<T>, Array, Dictionary 等本地集合进行查询。
使用自定义的 .NET 方法：当查询逻辑包含无法转换为 SQL 的复杂方法时。
小数据集处理：当确定数据集很小，或者数据已经加载到内存中时。


3. left join  right join 跟inner join

* INNER JOIN（内连接）：
返回两个表中匹配的行。
只有当左表（第一个表）和右表（第二个表）中的行满足连接条件时，才会返回该行。
如果左表中的行在右表中没有匹配，或者右表中的行在左表中没有匹配，则不会返回这些行。

* LEFT JOIN（左连接）：
返回左表中的所有行，即使右表中没有匹配的行。
如果左表的某行在右表中没有匹配，则右表的部分将返回NULL。
也称为LEFT OUTER JOIN。

* RIGHT JOIN（右连接）：
返回右表中的所有行，即使左表中没有匹配的行。
如果右表的某行在左表中没有匹配，则左表的部分将返回NULL。