## 乐观锁 悲观锁
我们通常将锁分为乐观锁和悲观锁，这两种锁其实是并发控制的两种不同的思想，并不是SQL Server中具体的锁模式。在SQL Server中，我们通常讨论的锁（共享锁、排他锁等）属于悲观锁的范畴。但是，SQL Server也提供了乐观并发控制机制，比如通过行版本控制（Row Versioning）来实现。

## 悲观锁：
悲观锁的核心思想是：假设会发生并发冲突，因此在访问数据之前先获取锁，确保在事务处理过程中数据不会被其他事务修改。
SQL Server中的共享锁、排他锁、更新锁等都属于悲观锁。这些锁在数据被访问时直接加在数据上，其他事务必须等待锁释放才能访问。
在默认的读已提交隔离级别下，当执行更新操作时，SQL Server会使用排他锁锁定数据，防止其他事务修改相同的数据。

## 乐观锁
乐观锁的核心思想是：假设不会发生并发冲突，因此在访问数据时不加锁
假设不会发生并发冲突，因此在访问数据时不加锁，而是在提交更新时检查数据是否被其他事务修改过。如果没有被修改，则提交更新；否则，回滚事务并报错。


### 悲观锁 - SQL Server 的默认策略
```
-- 默认情况下，SQL Server使用悲观锁
BEGIN TRANSACTION
-- 这里会自动加锁（S锁用于SELECT，X锁用于UPDATE等）
SELECT * FROM Products WHERE ProductID = 1
UPDATE Products SET Price = 20 WHERE ProductID = 1
COMMIT TRANSACTION
```




在SQL Server中，锁是用于管理多个用户同时访问和修改数据库数据的一种机制，以确保数据的一致性和完整性。锁可以防止脏读、不可重复读和幻读等问题。

1. 共享锁（Shared Locks）：
用于读取操作，如SELECT。
多个事务可以同时持有共享锁，但此时不能有排他锁。
一旦数据被加上了共享锁，其他事务可以继续加共享锁，但不能加排他锁。

2. 排他锁（Exclusive Locks）
用于数据修改操作，如INSERT、UPDATE、DELETE。
一个事务持有排他锁后，其他事务不能加任何类型的锁（包括共享锁和排他锁）。
排他锁会一直持有直到事务结束。

3. 更新锁（Update Locks）
用于更新操作，防止死锁。
更新锁在读取数据时类似于共享锁，但在修改数据时会升级为排他锁。
一次只能有一个事务可以获得更新锁，这样可以避免多个事务同时读取数据然后尝试更新时发生死锁。

