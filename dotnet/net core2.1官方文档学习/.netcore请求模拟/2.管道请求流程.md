参考：
https://www.cnblogs.com/artech/p/rebuild-pipeline-02.html

建立一个控制台程序：

.NET Core请求处理管道由一个服务器和一组中间件构成


一、建立在“模拟管道”上的应用


# 二、HttpApplication——一组中间件的有序集合

ASP.NET Core请求处理管道由一个服务器和一组有序排列的中间件组合而成。
我们可以在这基础上作进一步个抽象，将后者抽象成一个HttpApplication对象，那么该管道就成了一个Server和HttpApplication的综合体（如下图所示）。
Server会将接收到的HTTP请求转发给HttpApplication对象，后者会针对当前请求创建一个上下文，并在此上下文中处理请求，请求处理完成并完成响应之后HttpApplication会对此上下文实施回收释放处理。

我们通过具有如下定义的IHttpApplication<TContext>类型来表示上述的这个HttpApplication，
泛型参数TContext代表它针对每个请求而建立的上下文。
一个HttpApplication对象在接收到Server转发的请求之后需要完成三项基本的操作，
#1.创建上下文 2.在上下文中处理请求 3.请求处理完成之后释放上下文，
这三个基本操作正好通过对应的三个方法来完成。

public interface IHttpApplication<TContext>
{
   TContext CreateContext(IFeatureCollection contextFeatures); 
   Task ProcessRequestAsync(TContext context);
   void DisposeContext(TContext context, Exception exception);
}
用于创建上下文的CreateContext方法具有一个类型为IFeatureCollection接口的参数。
顾名思义，这个接口用于描述某个对象所具有的一组特性，
我们可以将它视为一个Dictionary<Type, object>对象，字典对象的Value代表特性对象，Key则表示该对象的注册类型（可以是特性描述对象的真实类型、真实类型的基类或者实现的接口）。
我们可以调用Get方法根据指定的注册类型得到设置的特性对象，特性对象的注册则通过Set方法来完成。我们自定义的FeatureCollection类型采用最简单的方式实现了这个接口。


管道采用的HttpApplication是一个类型为 HostingApplication的对象。这个类型实现了接口IHttpApplication<Context>，泛型参数Context是一个针对当前请求的上下文对象。
一个Context对象是对一个HttpContext的封装，后者是真正描述当前HTTP请求的上下文，承载着最为核心的上下文信息。
除此之外，我们还为Context定义了Scope和StartTimestamp两个属性，两者与日志记录和事件追踪有关，前者被用来将针对同一请求的多次日志记录关联到同一个上下文范围（即Logger的BeginScope方法的返回值）；后者表示开始处理请求的时间戳，如果在完成请求处理的时候记录下当前的时间戳，我们就可以计算出整个请求处理所花费的时间。


管道采用的HttpApplication是一个类型为 HostingApplication的对象。如下面的代码片段所示，这个类型实现了接口IHttpApplication<Context>，泛型参数Context是一个针对当前请求的上下文对象。一个Context对象是对一个HttpContext的封装，后者是真正描述当前HTTP请求的上下文，承载着最为核心的上下文信息。除此之外，我们还为Context定义了Scope和StartTimestamp两个属性，两者与日志记录和事件追踪有关，前者被用来将针对同一请求的多次日志记录关联到同一个上下文范围（即Logger的BeginScope方法的返回值）；后者表示开始处理请求的时间戳，如果在完成请求处理的时候记录下当前的时间戳，我们就可以计算出整个请求处理所花费的时间。

# HttpApplication相关的核心接口/类型之间的关系
通过泛型接口IHttpApplication<TContext>表示HttpApplication是对注册的中间件的封装。
HttpApplication在一个自行创建的上下文中完成对服务器接收请求的处理，
而上下文根据表述原始HTTP上下文的特性集合来创建，
这个特性集合通过接口IFeatureCollection来表示，FeatureCollection是该接口的默认实现者。


# 三、HttpContext——对当前HTTP上下文的抽象
用来描述当前HTTP请求的上下文的HttpContext对于ASP .NET Core请求处理管道来说是一个非常重要的对象，
我们不仅仅可以利用它获取当前请求的所有细节，还可以直接利用它完成对请求的响应。
HttpContext是一个抽象类，很多用于描述当前HTTP请求的上下文信息的属性被定义在这个类型中。
在这个这个模拟管道模型中，我们仅仅保留了如下两个核心的属性，即表示请求和响应的Requst和Response属性。

ASP.NET Core默认使用的HttpContext是一个类型为DefaultHttpContext对象，
对应这个管道来说，请求的接收者和最终响应者都是服务器，服务器接收到请求之后会创建自己的上下文来描述当前请求，针对请求的响应也通过这个原始上下文来完成。
以我应用中注册的HttpListenerServer为例，由于它内部使用的是一个类型为HttpListener的监听器，所以它总是会创建一个HttpListenerContext对象来描述接收到的请求，针对请求的响应也是利用这个HttpListenerContext对象来完成的。

但是对于建立在管道上的应用来说，它们是不需要关注管道究竟采用了何种类型的服务器，更不会关注由这个服务器创建的这个原始上下文。
实际上我们的应用不仅统一使用这个DefaultHttpContext对象来获取请求信息，同时还利用它来完成对请求的响应。很显然，应用这使用的这个DefaultHttpContext对象必然与服务器创建的原始上下文存在某个关联，这种关联是通过上面我们提到过的这个FeatureCollection对象来实现的。

server->server context 
                        -> Context Feature -> Default ->App
server->server context

一旦了解DefaultHttpContext是如何操作原始HTTP上下文之后，对于DefaultHttpContext的定义就很好理解了。
DefaultHttpContext具有一个IFeatureCollection类型的属性HttpContextFeatures，
它表示的正是由服务器创建的用于封装原始HTTP上下文相关特性的FeatureCollection对象。
通过构造函数的定义我们知道对于一个DefaultHttpContext对象来说，表示请求和响应的分别是一个DefaultHttpRequest和DefaultHttpResponse对象。

由不同类型的服务器创建的特性对象之所以能够统一被DefaultHttpContext所用，
原因在于它们的类型都实现统一的接口，在模拟的管道模型中，我们定义了如下两个针对请求和响应的特性接口IHttpRequestFeature和IHttpResponseFeature，
它们与HttpRequest和HttpResponse具有类似的成员定义。

实际上DefaultHttpContext对象中表示请求和响应的DefaultHttpRequest和DefaultHttpResponse对象就是分别根据从提供的FeatureCollection中获取的HttpRequestFeature和HttpResponseFeature对象创建的


在了解了DefaultHttpContext的实现原理之后，我们在回头看看上面作为默认HttpApplication类型的HostingApplication的定义。由于对请求的处理总是在一个由HttpContext对象表示的上下文中进行，所以针对请求的处理最终可以通过具有如下定义的RequestDelegate委托对象来完成。
一个HttpApplication对象可以视为对一组中间件的封装，它对请求的处理工作最终交给这些中间件来完成，所有中间件对请求的处理最终可以转换成一个RequestDelegate对象，HostingApplication的Application属性返回的就是这么一个RequestDelegate对象。

当我们创建一个HostingApplication对象的时候，需要将所有注册的中间件转换成一个RequestDelegate类型的委托对象，
并将其作为构造函数的参数，ProcessRequestAsync方法会直接利用这个委托对象来处理请求。
当CreateContext方法被执行的时候，它会直接利用封装原始HTTP上下文的FeatureCollection对象创建一个DefaultHttpContext对象，进而一个Context对象。
在简化的DisposeContext方法中，我们只是调用了Context对象的Scope属性的Dispose方法（如果Scope存在），实际上我们在创建Context的时候并没有Scope属性进行初始化。

# 四、服务器——实现对请求的监听、接收和响应

管道中的服务器通过IServer接口表示，在模拟管道对应的应用编程接口中，我们只保留了两个核心成员，其中Features属性返回描述服务器的特性，而Start方法则负责启动服务器。
Start方法被执行的时候，服务会马上开始实施监听工作。
HTTP请求一旦抵达，该方法会利用作为参数的HttpApplication对象创建一个上下文，并在此上下文中完成对请求的所有处理操作。
当完成了对请求的处理任务之后，HttpApplication对象会自行负责回收释放由它创建的上下文。

在我们演示的发布图片应用中使用的服务器是一个类型为HttpListenerServer的服务器。
顾名思义，这个简单的服务器直接利用HttpListener来完成对请求的监听、接收和响应工作。
这个HttpListener对象通过Listener这个只读属性表示，我们在构造函数中创建它。
对于这个HttpListener，我们并没有直接为他指定监听地址，监听地址的获取是通过一个由IServerAddressesFeature接口表示的特性来提供的。
，这个特性接口通过一个字符串集合类型的Addresses属性表示监听地址列表，ServerAddressesFeature是这个特性接口的默认实现类型。在构造函数中，我们在初始化Features属性之后，会添加一个ServerAddressesFeature对象到这个特性集合中。

由于HttpListenerServer采用一个HttpListener对象作为监听器，由它接收的请求将被封装成一个类型为HttpListenerContext的上下文对象。
我们通过一个HttpListenerContextFeature类型来封装这个HttpListenerContext对象。
如下面的代码片段所示，HttpListenerContextFeature实现了IHttpRequestFeature和IHttpResponseFeature接口，HttpApplication所代表的中间件不仅仅利用这个特性获取所有与请求相关的信息，而且针对请求的任何响应也都是利用这个特性来实现的。

