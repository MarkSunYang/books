1.  Q:java中的static、final、static final
    A:   总结：
        1.final修饰的类不能被继承
        2.finla修饰的方法不能被重写
        3.final修饰的类属性和变量属性必须要进行显示初始化赋值。
        4.final修饰的值类型初始化后无法被修改，
        引用类型指向的是实际对象，但其存储的是所指向对象的地址，因此，其值不能修改并不意味着其所指向的对象不能修改。


        1.static修饰的属性的初始化在编译期（类加载的时候），初始化后能够改变
        2.static修饰的属性所有对象都只有一个值
        3.static修饰的属性强调他们只有一个
        +4.static修饰的属性、方法、代码跟该类的对象无关，不创建对象也能调用static修饰的属性、方法等
        +5.static不可以修饰局部变量。

        ==》静态类，静态方法，静态字段~~

        1.static final和final static没什么区别，一般static写在前面

        哇，又想到了C#  的const和readonly 当然 const不是一种语言的专享

        既然说道这里~~我们就比比下编译的时候做了些啥~
        http://blog.csdn.net/mccand1234/article/details/52013918

        1.java代码编译是由java源代码编译完成
        源代码=>词法分析=>Token流=>语法分析=>语法树/后巷语法树=>语义分析=>注解抽象语法树=>字节码生成器=>JVM字节码
        2.java字节码（class文件）的执行是jvm执行引擎完成（~~看天书了，深入理解jvm吧）
        ~~
        java代码编译执行包含了如下机制
        java源代码编译

        类加载机制 通过classLoader及其子类来完成
        =>Custom classLoader属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现
        =>App classLoader 负责记载classpath中指定的jar包及目录中class 
        =>Extension classLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包 
        =>BootStrap classLoader 负责加载 $JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类 

       ~~~
        编译时是调用检查你的源程序是否有语法错误，如果没有就将其翻译成字节码文件。即.class文件。
        运行时是java虚拟机解释执行字节码文件。
        
        java中没有const关键字，java常量用 static final 表示

        1.当前类中 static修饰的变量都是可以用类名直接访问的

