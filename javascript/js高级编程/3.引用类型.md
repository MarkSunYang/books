本章内容
使用对象
创建并操作数组
理解js的类型
使用基本类型和基本包装类型

引用类型的值，是引用类型的一个 实例，引用类型是一个数据结构，用于将数据和功能组织在一起，它常被称做是一个类，
引用类型那个有时候被成为对象定义，因为他们是描述一类对象的属性和方法
虽然引用类型和类看起来相似，但是并不是相同的概念，
对象是某个特性引用类型的实例，新对象是new操作符后面跟一个函数来创建的，构造函数本生就是一个函数，只不过该函数是处于创建新对象的目的而定义的
var person=new Object();
这行代码创建了Object引用类型的一个新的实例，然后把该实例保存在了变量的person中，使用的构造函数是Object，它只为新对象定义了默认的属性和方法，

1.1 Object 类型
到目前位置，我们看到的大多数值类型都是Object类型的实例，Object也是js中使用的最多的类型，虽然Object 实例具备不少的功能，但是对于应用程序中存储和传输数据而言，他们确实是非常理想的选择
创建Object的方式有两种，一种是New 操作符 
var person=new Object();
另一种是对象字面量
var person={
    name:"Nicholas",
    age:29
};
在通过字面量定义对象，实际上不会调用Object构造函数，
一般来说，访问对象属性时，使用的都是表示方法，这也是很多面向对象方法中通用的语法，不过js中可以使用[]来表示访问对象的属性，
alert(person["name"]);
alert(person.name);
这两种访问对象属性的方法没有任何区别，但是在括号中的主要有点是可以通过变量来访问属性
如果属性中包含导致语法错误的字符，或者属性名称使用的关键字是保留字，也可以使用方括号来表示

1.2 Array 类型
js中的数组跟其他编程语言的数组区别很大，js数组可以保存不同类型的数据，并且是可以动态调整的
创建数组的方式有两种，
第一种是使用
Array var color= new Array(20); 20是数组的 长度
也可以向Array构造函数传递数组中应该包含的项，一下创建了一个包含3个字符串的数组
var color=new Array("red","blue","green");
构造函数传递一个值也可以创建数组，
第二种是 使用数组字面量方法表示，数组字面量是由一对包含数组的方括号表示，多个数组之间以逗号隔开
var colors=["re","blue"];
var name=[];
以上代码的第一行创建了一个包含3个字符串的数组，第二行使用一对空方括号创建了一个空数组，第三行展示了数组字面量的最后一行添加逗号隔开的结果
和对象一样，在使用数组字面量表示，也不会调用Array的构造函数
在读取和设置数组的值的时候，要使用方括号，并提供相应值的基于0的数字索引，
color[0]
如果索引小鱼数组的项数，则返回对应项的值，设置数组的值也会使用相同的语法，但会替换指定的位置的值，如果设置某个值的索引超过了现有数组项长度数组就会自动增加索引到该索引值加1的长度，这个跟java，c中不一样，所以js没有数组越界
数组的length属性有一个特点，他不是只读的，因此，通过设置这个属性，可以从数组的末尾移除或者向数组中添加新项，
var color=["red","blue","green"]
var name=[];
数组中的值，如果不设置，则会是undefined

1.2.1 检测数组
ECMAScript3做出了规定，确定了某个对象是不是数组的经典问题
对于一个网页或者从一个全局作用域而言，使用instanceof操作符就能得到满意的结果
if(value instanceof Array){
    //对数组执行某些操作
}
instanceof操作符的问题在于，他至嘉定只有一个全局执行环境，但是如果网页中有多个框架，那么实际上就在两个以上不同的全局执行，从而存在两个以上不同版本的Array构造函数，如果你从一个框架向另一个框架传入数组，那么传入的数组和第二个框架中创建的数组分别
各自不同的构造函数，
为了解决这个问题，ECMAScript新增了Array.isArray()方法，这个方法的目的是最终确定某个值到底时是不是数组，而不管他是那个全局执行环境中执行创建的

1.2.2 转换方法
所有对象都有toLocaleString(),toString()和valueOf()方法，其中调用数组的toString()方法会由数组中每个值的字符串形式凭借而成的逗号分隔开
console.log(arrColor.toString());显示的调用了toString()方法，以便返回数组的字符串
console.log(arrColor.toLocaleString());
console.log(arrColor.valueOf());valueOf()方法，最后一行代码直接将数组传递给了alert()，由于alert()要接受字符串参数，所以他不会在后台调用toString()方法，由此得到与直接调用toString的方法
console.log(arrColor);

1.2.3 栈方法
数组童工了一种让数组的的行为类似其他数据结构的方法，数组可以表现的就像栈一样，后者是一种可以限制插入和删除的数据结构，
栈是一种LIFO的数据结构，数组的push()和pop()方法

1.2.4 队列方法
栈数据结构事故先进后出，而队列数据结构的访问规则是先进先出，队列在队列表的末端添加选项，从列表的前端一处啊
push是向数组末端添加的方法，因此要模拟队列只需要从一个数组前端取得项的方法，这一个操作的方法就是shift
他能够移除数组中的第一个选项，并返回该项目，

1.2.5 重新排序
数组中存在了两个可以直接用来排序的方法reverse和sort

reverse 数组反转排序
sort 按照升序排列数组项，最小的值位于最前面，最大值在最后面，为了实现排序，sort方法会调用每个数组项的toString()转型方法
然后比较得到的字符串，以确定数组中的每一项都是数值，
      var values=[1,2,3,4,5,10,11];
        console.log(values.reverse());
        console.log(values.sort());
即使栗子中的排序没有问题，但是sort方法还会根据字符串的结果改变原来的顺序
因为数值5虽然小于10，但是在进行字符串比较的时候，10则位于5的前面，于是数组的顺序就被修改了，这种排序方法在很多情况下都不是最佳防范，因此sort方法可以接受一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面
比较函数接受两个参数，

1.2.6 操作方法
ECMAScript 已经为操作已经包含在数组中的项提供了很多方法，
concat()方法可以基于当前数组中的俄所有创建一个新数组，具体来说，这个方法会创建当前一个数组的副本，
然后将接收到的参数添加到这个副本的末尾，然后返回新构建的数组，在没有contact()方法传递参数的情况下，
他只是赋值当前数组并返回副本，如果传递给concat方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到数组结果中

slice() 能够基于当前数组中的一或多个项创建一个新数组，Slice方法可以接受以或两个参数，既要返回项的其实和结束位置
在只有一个参数的情况下，slice方法返回从该参数指定位置到当前数组末尾的所有项，

splice 方法 
删除：可以删除任意量的项，参数， 第一个项的位置和要删除项的位置和要删除 splice(0,2)会删除数组中的前两项
插入：可以向指定位置插入任意量的项，只要提供3个参数，其实位置，要插入的项目，如果是多想，可以传入
splice(2,0,"red") 从当前数组的位置2开始插入字符“red”
替换：可以向执行位置插入任意数量的项
splice(2,1,"red")
splice始终都会返回一个数组，该书组包含从原始数组中删除的项

1.2.7 位置方法
indexOf() 和lastIndexOf() 。这两个方法都接受两个参数，要查找的项和表示查找起点位置的缩影，其中，indexOf方法从
数组的开头向后查找，lastIndexOf从数组的末尾开始向前查找

1.2.8 迭代方法
js中的五个迭代方法，每个方法都接受两个参数，要在每一项上运行的函数和该函数的作用域对象，
影响this的值，传入这些方法中的函数会接受三个参数，数组项的值，该项在数组中的位置和数组本身对象，
every() 对数组中的每一项运行给定函数每一项运行给定函数，如果该函数对每一个项都返回true，则返回true
filter() 对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组
forEach() 对数组中的每一项运行给定函数，这个方法没有返回值
map() 对数组中的每一项运行给定函数，分拿回每次函数调用的结果组成的数组
some()对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true

最相似的是every() 和some() 他们都用于查询数组中，他们都用户查询数组中的各项是否满族某个条件
对于every() 来说，传入的函数必须对每一项都返回true，


1.2.9 归并方法
ES5新增了两个归并数组的方法，reduce和reduceRight，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值，reduce方法从数组的第一项开始，逐个遍历到最后，而reduceRught从数组的最后一项开始，向前遍历到第一项

2.1 Date类型
ES的date类型实在早起java中的java.until.Date类基础上构建的，为此，Date类型使用来自UTC 
Date构造函数不传递参数的情况下，新创建的对象自动获得当前的日期和时间，如果根据特定的日期和时间和日期，必须传入该日期的毫秒数，Date.parse() Date.UTC()
Date.parse() 方法接受一个表示日期的字符串参数，参数格式
月/日/年  6/13/2009
英文月 日，年   January 12,2009
Tue May 25 2009 

Date.UTC()方法同样也会表示日期的毫秒数，但它和Date.parse()在构建值的时候信息不同，

时间日期的格式化
时间日期的方法

3.1RegExp 类型
ES通过RegExp来支持正则表达式，使用类似Perl的语法，就可以创建一个正则表达式
var expression = /pattern/ flags;
pattern 的部分可以是任意简单或复杂的正则表达式，可以包含字符类，限定符，分组，
向前查找以及反向引用，每个正则表达式都可以带一个或多个flags，用以表明正则表达式的行为，
正则表达式的匹配模式支持下列三个标志：
g: 表示全局，即模式将被应用到所有字符串，而非在发现第一个匹配项时立刻停止
i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写
m：表四多行模式
eg:
匹配字符串中所有 at 的实例
var pattern1= /at/g;

匹配第一个 bat 或 cat 不区分大小写
var pattern2= /[bc]at/i;

匹配所有 at 结尾的三个字符串的组合，不区分大小写，
var pattern3 =/.at/gi;


4.1 Function类型
函数实际上是一个对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法，
由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定，函数通常是使用函数语法定义的
function sum(){}
var sum=function(){}
以上代码定义了变量sum并将其初始化为一个函数，
最后一种函数定义的方式是使用Function构造函数，Function构造函数可以直接接受任意数量的参数，但是最后一个参数始终都被看成是函数体，而恰面的参数则美剧除了新函数的参数
var sum=new Function("num1","num2", "return num1+num2");
这是一个函数表倒是，这种雨打会导致代码解析两次，第一次是ES解析，第二次是解析传入构造函数中的字符串

4.1.2 没有重载
将函数名想象为指针，也有助于理解为什么es没有函数重载的概念，因为函数声明会覆盖

4.2.3 函数声明和函数表达式
函数声明和表达式加以区别，解析器在向执行环境中工加载数据，对函数声明和表达式并非一样，解析器会率先读取函数声明
并且在执行代码之前可用，至于函数表达式，必须等到解析器执行到他所在的代码，才会被真正执行

alert(sum(1,2))
function sum(num1,num2){ return num1,num2;}
以上代码完全可以正常执行，因为在代码开始执行之前，解析器就已经通过一个函数声明提升的过程（function declaration hosting）并读取将函数声明添加到执行环境中，对代码求值，js引擎会在第一遍声明函数并将他们放到
源代码树的顶部，即使函数的代码在调用他的代码后，js也能把函数声明提升到顶部

4.2.4 作为值的函数
es中的函数本身就是变量，所以函数也可以作为值来使用，

4.2.5 函数内部属性
两个特殊属性， arguments 和 this 
arguments 的作用是保存参数，虽然arguments的主要作用是保存函数参数，
这个对象还有一个callee的该属性是一个指针，指向拥有这个arguments的对象
  
    function factrial(num){
        if(num<1){
            return 1
        }else{
            return num * factrial(num-1);
        }
    }
定义阶乘一般都要用到递归算法有函数名字，而且以后名字也不会边的情况下没有问题
但是这个函数的执行和函数名称耦合在了一起，为了消除这种现象，可以使用arguments.callee
function method2(num){
    if(num<=1){
        return 1;
    }else{
        return num * arguments.callee(num-1);
    }
}
arguments.callee，该属性是一个指针，指向拥有这个arguments对象的函数
这里的this，和javaC#大致类似，this引用的函数执行的环境对象，
sayColor()是在全局作用域中定义的，它引用了this对象，由于在调用函数之前，this的值并不确定，
因此this可能会在代码执行中引用不同的对象
当在全局作用域中调用sayColor this引用的是全局对象window，
对this.color求值会转换成对window.color求值返回red当吧这个函数对象赋给o，并调用o.sayHello()this对象
引用的是o

ES5 规范了另一个函数对象的属性 caller，

4.2.6 属性和方法
es中的函数是对象，因此函数也有属性和方法，每个函数都包含两个属性，length 和 protoype。 其中，length属性表示函数希望接受的命名参数的个数，

每个方法都包含两个非继承的方法 apply和call，这两个方法的用途都是在特定的作用域中


5.1基本包装类型
为了便于操作基本类型，es提供了3个特殊的引用类型，boolean，numner和stirng，这些基本类型和其他引用类型相似，但是具备个子的基本类型相应的特殊行为
实际上，每当读取一个基本类型的时候，后台就会创建一个对应的基本包装的对象，
var s1=""
var s2=s1.substring()
这个栗子中的变量s1包含了字符串，字符串当然是基本类型值，而下一行调用了s1的substring方法，并将返回的结果保存在了s2中，
基本类型值不是对象，而逻辑上他们不应该有方法，后台自动完成了一些列的操作，当第二行访问s1，访问过程处于一种阅读模式，
1).创建String类型的一个实例
2).在实例上调用指定的方法
3).销毁这个实例
引用类型和基本类型的蛀牙区别就是对象生存周期，
