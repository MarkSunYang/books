
# Thread
                    新建状态
                    ->执行start方法
                                        <——
                    就绪状态               |
                                        阻塞状态     线程阻塞
 系统调度，获取资源   ->执行run方法

                    运行状态               |   
                    ->run方法执行完成

死亡状态： 可以用stop强制终止


新建状态:
使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
绪状态:
当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
运行状态:
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。


# 创建线程
通过实现 Runnable 接口；
通过继承 Thread 类本身；
通过 Callable 和 Future 创建线程。


1. 通过Runnable 接口来创建线程
为了实现Runnable 只需要执行一个方法调用run()
public void run()
该方法可以重写，run可以调用其他方法，使用其他类，并声明变量，新线程创建后，使用start()执行

2. 通过集成Thread 来创建线程
创建一个线程的 第二种方法是创建一个新的类，该类型继承Thread类，然后创建一个该类的实例，继承类必须重写run()方法，该方法的新线程的入口点，他必须调用start方法
但是本质上也是实现了 Runnable 接口的一个实例。

线程同步
线程间通信
线程死锁
线程控制：挂起、停止和恢复


----------------------------------------------------------------
multitasking 多任务
thread 线程
mutithread 多线程程序


synchronized (this)和 synchronized方法都是锁当前对象


run 是方法调用
start 启动线程



# 线程同步：


死锁原理：
thread在执行过程中锁住了某个对象，


# java 线程总结
1. 多线程做作用：

2. 创建线程的方式
  实现 Runnable接口，这样比较灵活
  继承thread类

3. start 和 run 方法的区别
调用了start 方法才会表现出多线程的特性，不同线程的run方法代码交替执行。
如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。

4. java 内存模型
在并发编程需要处理的两个关键问题是：线程之间如何通信 和 线程之间如何同步。

通信：通信是指线程之间以何种机制来交换信息
共享内存模型：线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式进行通信
消息传递的并发模型：线程之间没有公共状态，线程之间必须通过明确的消息来显示进行通信

同步：程序用于控制不同线程之间操作发生相对顺序的机制
在共享内存的并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
在消息传递的并发模型里，由于消息的发送必须在消息的接受之前，因此同步是隐式进行的。

#JAVA 内存模型的抽象
所有实例域 静态域 和 数组元素 存储在内存堆中。
堆内存在线程之间共享。
局部变量、方法定义参数 和 异常处理参数 不会在线程之间共享。所以不会有内存可见性，也不受内存模型的影响。
java 线程之间的通信由 java内存模型 JMM控制。
。JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。
从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。
本地内存是 JMM 的一个抽象概念，并不真实存在。

5. volatile 关键字的作用

6. 什么是线程安全

7. 死锁
死锁： 所谓死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
产生原因：1. 系统资源的竞争 2. 进程推进顺序非法 
3. 死锁产生的必要条件 产生死锁必须同时满足一下四个条件。只要其中任意一个条件不成立，就不会发生死锁
 互斥条件 ：进程要求对所分配的资源进行排他控制，即在一段时间内某资源仅一个进程所占有。若此时其他进程请求该资源，则请求进程只能等待。
 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有

 8. 怎么唤醒一个阻塞的线程
 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

 9. 