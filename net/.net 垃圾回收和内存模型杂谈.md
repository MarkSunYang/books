工具 dotnet trace

对于应用创建的大多数对象，可以依赖 .NET 的垃圾回收器来处理内存管理。 但是，如果创建包括非托管资源的对象，则当你在应用中使用完非托管资源后，必须显式释放这些资源。 最常用的非托管资源类型是包装操作系统资源的对象，如文件、窗口、网络连接或数据库连接。 虽然垃圾回收器可以跟踪封装非托管资源的对象的生存期，但无法了解如何发布并清理这些非托管资源。

#托管资源：在堆中的资源，垃圾回收会管理
#非托管资源：

通过实现 Dispose 方法来释放应用程序使用的非托管资源。 .NET 垃圾回收器不分配或释放非托管内存。

#装箱和拆箱为何损耗性能

#int tostring的写法
p+i
p+i.ToString()
第一种程序中执行的效率比第二种要低


# 1.垃圾回收的基础
在公共语言运行时 (CLR) 中，垃圾回收器用作自动内存管理器。 它提供如下优点：
1. 使你可以在开发应用程序时不必释放内存。
2. 有效分配托管堆上的对象。
3. 回收不再使用的对象，清除它们的内存，并保留内存以用于将来分配。 托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。
4. 通过确保对象不能使用另一个对象的内容来提供内存安全。

# 1.2内存基础知识
下面的列表总结了重要的 CLR 内存概念。

1. 每个进程都有其自己单独的虚拟地址空间，同一台计算机上的所有进程共享相同的物理内存，如果有页文件，则也共享页文件。
2. 默认情况下，32 位计算机上的每个进程都具有 2 GB 的用户模式虚拟地址空间。
3. 作为一名应用程序开发人员，你只能使用虚拟地址空间，请勿直接操控物理内存。 垃圾回收器为你分配和释放托管堆上的虚拟内存。
虚拟内存有三种状态
可用。 该内存块没有引用关系，可用于分配。
保留。 内存块可供你使用，并且不能用于任何其他分配请求。 但是，在该内存块提交之前，你无法将数据存储到其中。
提交。 内存块已指派给物理存储。

# 1.3垃圾回收的条件
当满足以下条件之一时将发生垃圾回收：
1. 系统具有低的物理内存。 这是通过 OS 的内存不足通知或主机指示的内存不足检测出来。
2. 由托管堆上已分配的对象使用的内存超出了可接受的阈值。 随着进程的运行，此阈值会不断地进行调整。
3. 调用 GC.Collect 方法。 几乎在所有情况下，你都不必调用此方法，因为垃圾回收器会持续运行。 此方法主要用于特殊情况和测试。

# 1.4托管堆
 在垃圾回收器由 CLR 初始化之后，它会分配一段内存用于存储和管理对象。 此内存称为托管堆（与操作系统中的本机堆相对）。
每个托管进程都有一个托管堆。 进程中的所有线程都在同一堆上分配对象记忆。

# 代数
堆按代进行组织，因此它可以处理长生存期的对象和短生存期的对象

第 0 代。 这是最年轻的代，其中包含短生存期对象。 短生存期对象的一个示例是临时变量。 垃圾回收最常发生在此代中。
 新分配的对象构成新一代的对象并且为隐式的第 0 代回收，除非它们是大对象，在这种情况下，它们将进入第 2 代回收中的大对象堆。
大多数对象通过第 0 代中的垃圾回收进行回收，不会保留到下一代。
第 1 代。 这一代包含短生存期对象并用作短生存期对象和长生存期对象之间的缓冲区。
第 2 代。 这一代包含长生存期对象。 长生存期对象的一个示例是服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象。