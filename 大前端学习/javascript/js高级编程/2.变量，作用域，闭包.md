内容：
理解基本类型和引用类型:  
理解执行环境:
理解垃圾回收:


1. 基本类型和引用类型
节本类型值：简单的数据段
引用类型值： 多个值构成的对象
在将一个值赋给变量的时候，解析器必须确定这个值
讲一个值赋给变量，解析器必须确定这个值是基本类型还是引用类型，5中基本数据类型 Undefined,Null,Boolean,Number,String
这5种基本数据类型是按值访问因为操作保存在变量的实际值中
引用类型的值是保存在内存对象中，js不允许直接访问内存位置，不能直接操作对象的内存空间，

动态属性：
对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法
var person=new Object();
person.name="malik";

执行环境：
执行环境是js中的一个重要概念，执行环境定义了变量或函数有权访问其他的数据，决定了他们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象
全局执行环境是最外围的一个环境，全局执行环境被认为是一个window对象，因此对所有全局变量和函数都是window对象的属性和方法创建的
某个执行环境中所有代码执行完成，该环境立刻被销毁，保存在其中的所有变量和函数也随之被销毁
每个函数都有自己的执行环境，当执行流进入一个函数，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其弹出，

当代码在一个环境中，会创建变量对象的一个作用域链（Scope Chain）作用域链的用途是保证对执行环境有访问的所有变量和函数的有序访问，作用域链的前端，始终都是当前执行的代码所在uanjing的变量对象，
如果这个环境是函数，则将其活动对象作为变量对象，活动对象最开始时只包含一个变量，即arguments对象，这个对象在全局环境中是不存在的，作用域链中的下一个变量来自包含外部环境，而再在一个变量赖在一个包含环境，这样一直延续到全局环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象
标识符解析是沿着作用域链一级一级的搜索标识的过程，搜索过程中始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符（如果找不到通常导致错误发生）
var color="blue";
function changeColor(){
    if(color=="red"){color="red";}
    else{color="blue";}
}
changeColor();
函数changeColor()的作用域链包含两个对象，
1).它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象，可以在函数内部访问变量color,就是因为可以在这个作用域链中找到他。
此外，在局部作中定义的变量可以在局部环境中与全局变量互换使用
var color ="blue";

2.延长作用域链
虽然执行环境的变量类型总共有两种，全局变量和局部函数，但是还有其他方法来延长作用域链。
这么说是因为有些语句可以在作用域链的迁都临时增加一个变量对象，该变量会在代码执行后被移除，
try catch 的catch 和with语句可以延长

没有块级的作用域，
js没有跨级作用域经常会导致理解困惑，js的作用域不在{}里面，
c 语言：
if(true){
    var color ="blue";
}
alert(color);
这里一个if语句中定义了color，如果在c,c++中，color会在if语句执行完毕后被销毁，但是js中，if语句中的变量会添加到当前的执行环境中（全局变量），在使用for循环的时候要牢记这一点差异
for(var i=0; i<10;i++){dosomething(i);}
alert(i);

2.1 声明变量
使用var 声明的变量会自动被添加到最接近的环境中，在函数内部，最接近环境的是局部环境，在with语句中，最接近的环境是函数环境，
如果初始化变量没有使用var，该变量会自动被添加到全局环境中 。
function add(num1,num2){
    var sum=num1+num2;
    return sum;
}
var result=add(10,20);
console.log(sum)
//因为sum的作用域是在add内部，所以会报错

2.2 查询标识符
当在某个环境中读取或写入一个引用一个标识符，必须通过读取或写入一个标识符时，必须通过搜索来确定该标识符实际代表什么，
搜索的过程中从作用域链的前端开始，向上逐级查询与给定名字 匹配的标识符，如果在局部变量中找到了该标识符，搜索过程停止，变量就绪，如果变量环境中没有找到改变辆名称，则继续沿着作用域链向上查找，知道追溯到全局环境的变量，如果全局变量中也没有，则意味着该变量没有声明




