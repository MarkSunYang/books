算法

1.插入排序
Insert-sort(A)
for j=2 to A.length
    key=A[j] 
    //Insert A[j] into the sorted sequence a[1..j-1]
    i=j-1
    while i>0 and A[i]>key
        a[i+1]=a[i]
    A[i+1]=key

循环不变式和插入排序的正确性：

算法的时间复杂度：
Insert-sort中，每条语句的执行时间和次数，j=2...n,n为a.length
最坏情况和平均情况


# 选择排序
每一趟从待排序的记录中选出最小的元素，然跟当前的数组比较（排除自己），然后互换位置：
var arr[]={3,10,12,9,1}

第一趟： 取3跟当前数组中元素比较 ，跟最小元素互换位置 1,10,12,9,3 i=0
第二趟： 取10更当前数组中元素比较，跟最小元素互换位置 1,3,12,9,10 i=1
第三趟： 取12更当前数组中元素比较，跟最小元素互换位置 1,3,9,10,12 
第四趟： 取12更当前数组中元素比较，跟最小元素互换位置 1,3,9,10,12

选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
所以，综上，简单排序的时间复杂度为 O(N2)。


算法的时间复杂度：用来度量算法的运行时间：T(n)=O(f(n));
它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来                                                             描述。
