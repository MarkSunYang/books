1.理解对象属性
2.理解并创建对象
3.理解继承


创建自定义对象的最简单方式就是创建一个Object，然后再为他添加属性和方法

1. 属性类型
数据访问属性好访问器属性
数据访问属性：
[[Configurable]]    表示能通过delete删除属性从而重新定义属性，能否修改属性的特性，能够把属性修改为属性访问器，默认为true
[[Enumerable]]      表示能够通过for-in来循环返回属性，默认为true，
[[Writeable]]       表示能够修改属性的值，默认true
[[Value]]           包含这个属性的数值，读取属性值的时候，从这个位置读写，

var person={
            name:"Mark"
        };
这里创建了一个为名name的属性，为他指定的是Mark，Value属性将被设置为Nicholas而对这个值的任何修改都反映在这个位置
要修改默认属性的默认特性，必须使用ES的Object.defineProperty()方法，这个方法接受三个参数：属性所在的对象，属性名称，一个描述对象，
 Object.defineProperty(person,"age",{
            writable:false,
            configurable:false,
            value:19
        });
添加了一个新的属性，writeable是false，表示不能赋新的值, configurable:false表示不能删除属性

2.访问其属性
访问其属性不包括数值，他们包含一对getter饿setter函数，这两个函数都不是必须的，访问其属性有四个特性
[[Configruable]] 表示是否能够通过delete 删除
[[Enumerable]]  表示能够通过for-in循环
[[Get]] 在读属性的时候调用, 默认undefined
[[Set]] 在写属性的时候调用，默认undefined


创建对象：

1. 工厂模式
工厂模式是常用的设计模式，这种模式抽象了创建具体对象的过程，用函数来封装特定接口创建对象的细节，
工厂虽然解决了创建多个相似对象的问题，但是没有解决对象识别的问题（怎么知道一个对象的类型）

2. 构造函数模式
ES中的构造函数可以来创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，也可以创建自定义的构造函数，
1)没有显式的创建对象
2)直接将属性和方法赋值给了this
3)没有return语句，
构造函数名Person的首字母大写，并且使用new关键字去创建对象，他经历了四个步骤
1).创建一个新对象
2).将构造函数的作用域赋给新对象（this指向了这个新对象）
3).执行构造函数中的代码（为这个新对象添加属性）
4).返回新对象
创建自定义的构造函数意味着将来可以将他的唯一标识为一种特定的类型，而这是构造函数模式胜过工厂模式的地方，
p1,p2都是Object的实例，因为所有对象均继承自Object

将构造函数当作函数，构造函数和其他函数的区别在于调用方式不同，但是构造函数也是函数，不存在定义的特殊语法，并且通过new来调用，
构造函数的问题：
构造函数对冉好用，但是并非没有缺点，每个方法都要在每个实例上创建，

3. 原型模式
我们每创建的函数都有一个原型propertype属性，这个属性是一个指针，指向一个对象，
而这个对象的用途是可以包含特定类型的所有实例共享的属性和方法，
如果按照字面上的意思来理解，那么property就是通过调用构造函数来创建的那个对象的原型对象，使用原型对象的好处
可以让所有对象共享他们包含的属性和方法，换句话说，不必在函数中定义对象实例的信息，

理解原型对象
无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，在默认情况下，所有原型对象都会自动一个constructor的属性，这个属性包含了指向prototype属性所在函数的指针，
创建了自定义的构造函数之后，原型对象默认只会取得construrctor属性，至于其他方法，则都是从Object继承而来，当调用构造函数创建一个新的实例之后，该实例内部将包含一个指针，指向构造函数的原型对象，
Person构造函数，Person的原型以及Person现有的两个实例之间的关系，

原型与 in 操作符
原型对象问题，
结构构造函数和原型模式

4. 继承
ES中没有接口继承，通过原型链来实现
ES中描述了原型链的概念，并将原型链作为实现继承的主要方法，其基本思想是利用原型链让一个引用类型那个继承另一个引用类型的属性和方法，简单回顾一下构造函数，原型，和实例的关系，每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而且每个实例都包含一个指向原型对象内部指针，
