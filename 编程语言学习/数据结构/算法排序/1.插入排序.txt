插入排序：
1).概念
已知 1到i-1的已排序序列，第i个数，往这个序列中插入

2).代码（伪）
var arr={9,7,3,4,5}
int temp
for(int i=1;i<arr.length;i++)
    temp=arr[i]
    while i>0 and arr[i-1]>temp
        arr[i]=arr[i-1]
        i--
    arr[i]=temp


3).时间空杂度
每次插入的时间成本
每次插入的情况
1.果新元素和他前面的所有元素相比，是最小的，那么新元素将会和前面所有元素逐一比较，并且还要互换位置，最后插入到最左边的位置
 8，9，10  arr[i]=7  那么7要比较三次才能排序成功
2.如果新元素比他前面的第一个元素还大，那么新元素只会和他前面的那个元素比较一次大小，然后插入
 7，8，9  arr[i]=10  那么不需要排序，这个序列就是顺序序列了
3.如果新元素比他前面的第一个元素还小，但是和他左边那些已排序的元素相比，又不会是最小的，那么新元素将会和所有比它大的元素比较，并且会互换位置，直到遇到第一个比他小的元素，和该元素进行一次比较，不会发生位置互换，比较完后直接插入
这样会分几种情况：
最慢：如果新元素比他前面所有元素都还小，满足前面所说的第一个情况。此时，比较操作和互换操作所执行的次数是一样的。我们假设在新元素前面共有m个元素，那么这次插入将会发生m次比较，m次互换。时间成本为：2m。
最快：如果新元素比他前面的第一个元素还大，满足前面所说的第二个情况，那么这次插入只会发生一次比较，没有互换。所以本次插入的时间成本为：1。
不是最快不是最慢：如果新元素比他前面的第一个元素还小，但是又不是前面所有的元素里最小的，满足前面所说的第三根情况
操作次数==互换操作+1

时间复杂度：
最快：如果待排序的数组本来就已经是排好序的，那么每次插入一个元素，都将满足前面所分析的“每次插入时间成本最快情况”，所以每插入一个元素的时间成本都为：1  N-1 = O(N)。
最慢：如果待排序的数组本来是全逆序的，那么每次插入一个元素，都将满足前面所分析的“每次插入时间成本最慢情况”，所以每插入一个元素的时间成本都为：2m


O(N²)

4).输入对时间成本的影响

