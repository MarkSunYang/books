# 栈 stack 队列 queue 和向量 vector

# 1.1单链表，双向链表，环形链表，带哨兵节点的链表；
链表相关概念及性质：
链表是一种常见的基础数据结构，是一种线性表，但是并不会按照线性表的顺序存储数据，而是在每个节点里存到下一个节点的指针。由于不须按照顺序存储，链表早插入的时候可以达到O(1)的复杂度，比顺序表O（logn）快的多，但是在查找一个节点或者访问特定编号的节点需要的时间为O（n）而顺序表的时间复杂度为O(1)，链表结构可以葱粉利用计算机的内存空间实现灵活的内存动态管理，但是链表失去了数组随机读取的优点，同事离岸边由于增加了节点的指针域，空间开销比较大。
链表由一连串节点组成，每个节点包含任意的实例数据（data fields）和一个或两个用来指向上一个或下一个节点的位置的链接（links）。链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据指针。链表允许插入和移除表上任意位置的节点，但是不允许随机存取，链表由很多不同的类型：单向链表，双向链表及循环链表。

# 1.1.1 单向链表或者单链表
1. 单向链表，它包含两个域，一个信息域和一个指针域
2. 单向链表，链接指向表中的下一个节点，而最后一个节点则指向一个空值NULL
3. 单向链表只可向一个方向遍历
4. 查找一个节点的时候需要
5. 也可以提前把一个节点的位置另外保存起来，然后直接访问。

# 1.1.2 双向链表
1. 双向链表中 不仅有指向后一个节点的指针，还有指向前一个节点的指针。
2. 双向链表第一个节点的  前连接 指向NULL，最后一个节点的 后连接 指向NULL
3. 双向链表 可以从任何一个节点访问前一个节点，也可以访问后一个节点，以至整个链表
4. 双向链表 一般是在需要大批量的另外存储数据和在链表中的位置的时候用
5. 双向链表由于另外存储了指向链表内容的指针，并且可能修改相邻的节点，有的时候第一个节点可能会被删除或在之前添加一个新的节点，这个时候需要修改收个节点的指针
6. 双向链表有一种方便的可以消除这种特殊的情况的方法是在最后一个节点，第一个节点之前存储一个永远不会被删除或者移动的虚拟节点，行程一个循环链表，这个虚拟节点知乎的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表

# 1.1.3 循环链表
1. 循环链表，首个节点和末节点被连接在一起，这种方式在单向和双向链表中都可以实现
2. 换转换一个循环链表，你开始于任意一个节点然后沿着表的任意方向指导返回开始的节点
3. 循环链表可以被视为“无头无尾”。循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通的链表更加容易
4. 对于新加入的节点应该是第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大
5. 另外有一种模拟的循环链表，也就是在访问到最后一个节点之后的时候，手工跳转到第一个节点之前的时候也一样，这样也可以实现循环链表的功能，在直接使用循环链表比较麻烦或者可能会出现问题的时候可以使用

# 1.1.3 带哨兵节点链表
1. 不带哨兵节点的双向链表在做查找删除节点等操作的时候，免不了要判断边界条件。如node=null等，每次判断边界条件，虽然不会从根本上增加时间复杂度，但是对齐常数项还是有影响的
2. 带哨兵节点构成的双向循环链表，则可以省去这些问题。我们使用一个“哑的”


# 2.栈的基本概念和性质，栈ADT及其顺序，链表实现；栈的应用；栈与递归

栈是LIFO last in first out 先进后出

ADT Stack{
    数据对象: D={ai|ai属于ElemSet, i=1,2...n}
    数据关系: 
    约定an端为栈顶，a1 端为栈底
    基本操作：
    InitStack(&S)       操作结果：构造一个空栈
    DestoryStack(&S)    初始条件：栈S已存在     操作结果：栈S被销毁
    ClearStack(&S)      初始条件：栈S已存在     操作结果：将S清为空栈 
    StackEmpty(&S)      初始条件：栈S已存在     操作结果：若为空栈，返回true，否则返回false
    StackLength(&S)     初始条件：栈S已存在     操作结果：返回S的元素个数，即栈的长度  
    GoTop(S,&e)         初始条件：用e返回S的栈顶元素
    Push(&S,e)          初始条件：栈S已存在     操作结果，插入元素e为新的栈顶元素
    Pop(&S,e)           初始条件：栈S已存在,且非空     操作结果，插入元素e为新的栈顶元素
    StackTraverse(S,visit())
}

栈的应用举例：数制转换，括号匹配的校验

# 1.3队列的基本概念和性质，队列ADT及其顺序，链接实现；队列的应用
队列的基本概念和性质：
1. 队列是一种线性集合，其元素一端加入，另一端删除，队列是先进先出FIFO方式处理
2. 队列的处理过程，通常会画成水平，其中一端作为队列的前端也称为队首，另一端作为队列的末端也称为队尾，元素都是从队列末端进入，从队列的前端退出
3. 在队列中，其处理过程可以在队列的两端进行，而在栈中，其处理过程只在栈的一端进行，但两者也有相似之处，与栈类似，队列中也没有操作能让客户抵达队列中部，同样也没有操作允许用户重组或删除多个元素。

队列链表与数组（顺序）的实现
1. 链表实现队列：
队列与栈的区别在于，我们必须操作链表的两端，因此除了一个指向链表首的元素引用之外，还需要另外跟踪另外一个指向链表末元素的引用。再增加一个整形变量count来跟踪队列元素个数，综合考虑，我们使用末端入列，前端出列

2. 数组实现队列：
固定数组的实现在栈中是很高效的，因为所有的操作（增删）都是在集合的 一端进行的，但是在队列的实现中不是这样的，因为我们在两端对队列进行操作，因此固定数组的实现效率不高


# 1.4 向量基本概念和性质；向量ADT及数组，链表实现
向量基本概念和性质
1. 对数组结构进行抽象之后，就可以得到向量结构，因此向量也称为数组列表（Array List）

2. 向量提供一些访问方法，使得我们可以通过下标直接访问序列中的元素，也可以将指定下标处的元素删除，或将新元素插入至指定下标，为了与通常数组结构的下标（index）概念区别出来，我们通常将序列的下标称为秩（Rank）

3. 假定集合S由n个元素组成，他们按照线性次序存放，于是我们可以直接访问其中的第一个元素，第二个元素。。。也就是说通过[0,n-1]之间的每个整数，都可以直接访问到唯一的元素e,而这儿整数等于S中位于e之前的元素个数，在此之前我们称为该元素的秩（Rank）

4. 不难看出，若元素e的秩为r，则只要e的直接前驱（或直接后继）存在，其中秩就是r-1
5. 支持通过秩直接访问其中元素的序列，称作为向量或数组列表
6. 实际上，秩这一直观概念的功能非常强大，他可以直接指定插入或删除元素的位置

ADT：
size                    向量当前的元素总数
get(r)                  获取秩为r元素的值              
put(r,e)                用e替换秩为r元素的数值
insert(r,e)             e作为秩为r的元素，返回该元素中存放的对象
remove(r)               删除秩为r的元素
disordered()            判断所有元素是否按照非降序排列
sort()                  调整各元素的位置，使之按降序排列
find(e)                 查找等于e且秩
search(e)               查找目标元素e，返回不大于e且秩最大的元素
deduplicate()
uniquify()
traverse()






